<!doctype html><html lang="ja"><head><meta charset="UTF-8" /><meta name="viewport" content="width = device-width, initial-scale = 1, user-scalable = yes" /><link rel="stylesheet" type="text/css" href="css/style.css" /><title>無門関 - 重畳関数について with Common Lisp part1</title></head><body><header id="main-header"><h1><a href="./index.html">無門関</a></h1></header><main><header id="article-header"><div id="date">2018-12-08</div><h2 id="title">重畳関数について with Common Lisp part1</h2></header><div id="article-main"><p>この記事は第8回関西Lispユーザ会で話す予定の内容をまとめているものです。 </p><p>このシリーズでは、Common Lispを使って重畳関数を実装し、またリスト意外のデータ構造に対しても重畳関数を一般化することで、重畳関数とは何かについて考えて行こうと思います。 ここでは、重畳関数という言葉はリストに対するものに限らないとして使うものとします。 </p><p>なにかありましたら、<a href="https://twitter.com/myao_s_moking/">@myao_s_moking</a>まで、ご連絡頂けると幸いです。優しく教えてね。 </p><p>今回は、リストの重畳関数を実装していきます。 </p><h3>reduce</h3><pre><code>CL-USER&gt; ;; (reduce func list :initial-value init) 以下func list initを使って説明します。  
CL-USER&gt; (reduce #'+ (list 1 2 3) :initial-value 0)  
6  
CL-USER&gt; (reduce #'- (list 1 2 3) :initial-value 0)  
-6  
CL-USER&gt; </code></pre><p>まず、上記の形の関数を実装することを考えます。 </p><pre><code>CL-USER&gt; (reduce #'+ (list 1 2 3) :initial-value 0) </code></pre><p>これは、以下のような計算を行っていることと同じです。 </p><pre><code>CL-USER&gt; (+ (+ (+ 0 1) 2) 3) </code></pre><p>まず、initの値とlistの最初の要素にfuncを適用します。 次に、その返り値とlistの次の要素にやはりfuncを適用します。 これをlistの要素がなくなるまで繰り返し、直前のfuncの返り値を返します。 </p><pre><code>CL-USER&gt; (defun my-reduce (func list init)  
       (if (null list)  
               init  
               (my-reduce func (cdr list) (funcall func init (car list)))))  
MY-REDUCE  
CL-USER&gt; (my-reduce #'+ (list 1 2 3) 0)  
6  
CL-USER&gt; </code></pre><p>素直に書くと、こんな感じでしょう。この状態では、まだ重畳関数を一般化していく方向性がつかみにくいと思います。 重畳関数を一般化するには、違った書き方をするほうが分かりやすいのですが、ここでは、このreduceがリストの要素を総なめているということを確認しておきましょう。 </p><p>リストの要素を各一回処理するという考え方では、リストの先頭から進む上記の形が分かりやすいですが、重畳関数を一般化するというシリーズの目的のためにも次の形のreduceについて考えます。 </p><pre><code>CL-USER&gt; ;; (reduce func list :initial-value init :form-end t) 以下func list initを使って説明します。  
CL-USER&gt; (reduce #'+ (list 1 2 3) :initial-value 0 :from-end t)  
6  
CL-USER&gt; (reduce #'- (list 1 2 3) :initial-value 0 :from-end t)  
2  
CL-USER&gt; </code></pre><p>これは他の言語では、foldrやreduceRightと呼ばれたりします。こちらは、以下のような計算を行ってることに相当します。 </p><pre><code>CL-USER&gt; ;; (reduce #'+ (list 1 2 3) :initial-value 0 :from-end t)  
CL-USER&gt; (+ 1 (+ 2 (+ 3 0))) </code></pre><p>こちらは、まずlistの最後の要素とinitにfuncを適用します、次はlistの最後から2番目の要素と直前のfuncの返り値をfuncに適用、 これを繰り返して、listの最初の要素がfuncの引数となるようなfuncの返り値が全体の返り値です。 説明が下手くそで申し訳ないので、実装を書きます。 </p><pre><code>CL-USER&gt; (defun my-foldr (func list init)  
           (if (null list)  
               init  
               (funcall func (car list) (my-foldr func (cdr list) init))))  
MY-FOLDR  
CL-USER&gt; (my-foldr #'+ (list 1 2 3) 0)  
6  
CL-USER&gt; (my-foldr #'- (list 1 2 3) 0)  
2  
CL-USER&gt; </code></pre><p>こちらの形のほうが、重畳関数の一般化を考えると分かりやすい形をしています。 </p><pre><code>(funcall func (car list) (my-foldr func (cdr list) init)) </code></pre><p>上の式に着目します。my-foldrが再帰になっているところを(cdr list)と書き換えます。 </p><pre><code>(funcall func (car list) (cdr list)) </code></pre><p>funcが#'consであれば、これはlistを返します。funcをcons、initをnilとして、my-foldrや:form-endがtのreduceを計算してみます。 </p><pre><code>CL-USER&gt; (my-foldr #'cons (list 1 2 3) nil)  
(1 2 3)  
CL-USER&gt; </code></pre><p>結果はlistと一致します。これはlistがどの様なものでも成り立ちます。あとで定義する一般化された重畳関数でもこれと同じ性質を持ちます。 </p><p>ここで、リストとは何かということを考えます。まずリストの先頭にある要素を付け足したものはリストです。つまり、次の式を考えます。 </p><pre><code>CL-USER&gt; (listp *list*)  
T  
CL-USER&gt; (listp (cons *elt* *list*))  
T  
CL-USER&gt; </code></pre><p>最初の式(listp <em>list</em>)が例のようにTであれば、二番目の式は<em>elt</em>に寄らずTとなります。リストに要素を追加することで新しいリストを作ることが出来ます。 これはconsがリストのコンストラクタの一つになっていることを表しています。 </p><p>もう一つリストを作る方法があります。それは空リストを作ることです。これは定数のnilです。 定数nilと関数consがあれば、順番に適用していくことでバラバラの要素をリストにすることが出来ます。 </p><pre><code>CL-USER&gt; (cons 3 (cons 2 (cons 1 nil)))  
(3 2 1)  
CL-USER&gt; </code></pre><p>my-foldrがそのままlistを返す例で、渡したconsとnilは、実はこのリストのコンストラクタになっているconsとnilです。 </p><p>つまり、重畳関数というのはconsとnilでリストを組み上げるのと同じように、代わりにfuncとinitで計算をしている関数と考えることが出来ます。 </p><p>Common Lispでは後のリストへのポインタを持つ片方向リストなので、consとnilのように綺麗には行きませんが、最初に考えたreduceでも同じ事が言えます。 </p><pre><code> CL-USER&gt; (reduce #'(lambda (list elt) (append list (list elt)))  
                  (list 1 2 3) :initial-value nil)  
 (1 2 3)  
 CL-USER&gt; </code></pre><p>こちらは、リストが空リストから始まり、後に要素を付け加えていくことで成るモノと思うことによる重畳関数です。 </p><p>さて、今回はこの辺りでおしまいとします。次回は、コンストラクタと重畳関数という観点で、木構造の重畳関数と自然数の重畳関数について実装を見ていきます。 </p></div><footer id="article-footer">UP: <a href=".html"></a> PREV: <a href="fold-with-lisp-1.html">fold-with-lisp-1</a> NEXT: <a href=".html"></a></footer></main><footer id="main-footer"><div id="icnos"><a href="https://twitter.com/myao_s_moking"><img src="img/twit.png" class="icon-img" /></a><a href="https://github.com/myaosato"><img src="img/github.png" class="icon-img" /></a></div><div id="copyright">&copy;2010 Satoaki Miyao</div></footer></body></html>