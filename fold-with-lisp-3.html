<!doctype html><html lang="ja"><head><meta charset="UTF-8" /><meta name="viewport" content="width = device-width, initial-scale = 1, user-scalable = yes" /><link rel="stylesheet" type="text/css" href="css/style.css" /><title>無門関 - 重畳関数について with Common Lisp part3</title></head><body><header id="main-header"><h1><a href="./index.html">無門関</a></h1></header><main><header id="article-header"><div id="date">2018-12-12</div><h2 id="title">重畳関数について with Common Lisp part3</h2></header><div id="article-main"><p>この記事は第8回関西Lispユーザ会で話す予定の内容をまとめているものです。 </p><p>このシリーズでは、Common Lispを使って重畳関数を実装し、またリスト意外のデータ構造に対しても重畳関数を一般化することで、重畳関数とは何かについて考えて行こうと思います。 ここでは、重畳関数という言葉はリストに対するものに限らないとして使うものとします。 </p><p>なにかありましたら、<a href="https://twitter.com/myao_s_moking/">@myao_s_moking</a>まで、ご連絡頂けると幸いです。優しく教えてね。 </p><p>今回は、色々な重畳関数を実装していきます。 </p><h3>リストの重畳関数</h3><p>前回はリストの重畳関数を実装することで、その関数の構造がリストのコンストラクタ(リストを作るための関数)と密接に関係していることが見えてきました。 実際、重畳関数は、リストのコンストラクタの代わりにコンストラクタと同じ様な引数を取る関数でリストを作り直したものと考えることが出来ます。 </p><p>今回は、その考え方を元に他の構造の重畳関数を実装していきます。 </p><p>まずは、リストの重畳関数を再度実装していきます。 </p><pre><code>CL-USER&gt; (defun fold-list (func1 func2 list)  
           (if (null list)  
               (funcall func2)  
               (funcall func1 (car list) (fold-list func1 func2 (cdr list)))))  
FOLD-LIST  
CL-USER&gt; (fold-list #'+ (lambda () 0) (list 1 2 3))  
6  
CL-USER&gt; (fold-list #'cons (lambda () nil) (list 1 2 3))  
(1 2 3)  
CL-USER&gt; </code></pre><p>重畳関数に与える引数とコンストラクタの関係がわかりやすくなるように、値を与えるreduceの:initial-valueも関数にしました。 </p><p>リストにはコンストラクタが2つあることは前回書きました。ここで、与える関数は、 </p><ol><li>コンストラクタの引数にリストが含まれない場合は、コンストラクタと同じ引数 (initial-valueと対応する方) </li><li>コンストラクタの引数にリストが含まれる場合は、コンストラクタの引数でリストとなっているところにはreduceの返り値となるものが期待される </li></ol><p>となっています。コンストラクタが再帰的にデータを組み上げて行きます。空リストから始まり、新しい要素をその前のステップで作られたリストの先頭に付け足していきます。 </p><pre><code>CL-USER&gt; (cons 1 (cons 2 (cons 3 nil)))  
(1 2 3) </code></pre><p>重畳関数は、これの逆にリストをまずばらしていく方向に再帰的に重畳関数を呼び出します。 再帰は(空リストのコンストラクタにリストを取らないので)空リストまで続いて、引数を取らない関数が呼び出されます。(上記のfunc2。) 再帰呼び出しが戻っていく時に、func1によって、要素とその呼び出しの戻り値を引数として、(まるでconsのように)重畳関数の返り値を組み上げていきます。 </p><p>この仕組みのために、consとnilを返す関数を重畳関数に与えると元のリストが返ってきます。 </p><h3>木構造の重畳関数</h3><p>復習が長くなってしまいましたが、他の構造に対して重畳関数を一般化していきましょう。まずは葉のみに値を持つ二分木構造を考えます。 </p><p>葉の部分のコンストラクタは値をそのまま返す関数とします。簡単のために以下では値はatomとします。 </p><p>もう一つコンストラクタがあり、これは右側に伸びる木構造と左側に伸びる木構造を組み合わせる関数です。これはconsを使うようにします。左側をcar、右側をcdrで取り出せます。 </p><p>数値かコンスセルかどうかで、木構造がどちらのコンストラクタで作られるものかは判別が付きます。 リストの場合には述べていませんでしたが、コンストラクタの逆関数、つまりコンストラクタの引数になるものを取り出す必要があるので、ここで話す重畳関数の一般化は、その様なデータ構造についての話になります。 この条件があっても多くデータ構造について一般化出来ます。(具体的な数学的バックグラウンドについては次回に書きます。) </p><pre><code>CL-USER&gt; (defparameter *tree* (cons (cons (cons 0 1) 2) (cons 3 4)))  
*TREE*  
CL-USER&gt; (defun fold-tree (f g tree)  
           (if (atom tree)  
               (funcall g tree)  
               (funcall f (fold-tree f g (car tree)) (fold-tree f g (cdr tree)))))  
FOLD-TREE  
CL-USER&gt; (defun id (x) x)  
ID  
CL-USER&gt; (equal (fold-tree #'cons #'id *tree*) *tree*)  
T  
CL-USER&gt; </code></pre><p>fold-treeが木構造(ただし葉にしか値を持たない二分木)版の重畳関数です。 gの方が葉のコンストラクタに対応し、fの方が2つの木を引数にとるコンストラクタに対応します。 重畳関数を再帰させるのは、リストのconsの場合の第二引数のように、コンストラクタの引数でその構造自身が期待される箇所になります。 今回のfold-treeの場合は、両側に木構造を期待するのでcar側もcdr側も再帰します。 </p><p>ところで、せっかくのなので、この関数を使っておきましょう。Common Lispの印字機能では、この木構造は一部がリストのように見えてよく分かりません。 よく分かる人もいるかもしれませんが、わからないことにしておきましょう。 </p><pre><code>CL-USER&gt; *tree*  
(((0 . 1) . 2) 3 . 4)  
CL-USER&gt; </code></pre><p>そこで、この構造を綺麗に出力したいと思います。葉は値の印字表現をそのまま使いその他のノードは左と右の木を--で結んだ形にします。ただし一つのノードから伸びている範囲をわかりやすくするために括弧でくくります。 言葉よりも実際に見てみるほうがわかりよいでしょう。 </p><pre><code>CL-USER&gt; (defun show-atom (v) (format nil "~A" v))  
SHOW-ATOM  
CL-USER&gt; (defun show-inode (lb rb) (format nil "(~A -- ~A)" lb rb))  
SHOW-INODE  
CL-USER&gt; (fold-tree #'show-inode #'show-atom *tree*)  
"(((0 -- 1) -- 2) -- (3 -- 4))"  
CL-USER&gt; </code></pre><p>私の発想が貧弱なので分かったような分からないような形ではありますが、標準のコンスセルの印字表現よりは分かりやすくなったのではないでしょうか。 </p><p>データ構造はプログラミングの至るところに出現しますが、重畳関数はその印字表現を与えるための関数を作る時に使えそうです。 </p><h3>自然数の重畳関数</h3><p>閑話休題、今回の最後に、少し変わった例を見ておきましょう。実は自然数もリストや木構造と同様に再帰的なデータ構造の一種だとみなすことが出来ます。 </p><p>最初の自然数である0を作るコンストラクタと、自然数を受け取り+1した自然数を返す2つのコンストラクタを考えると、すべての自然数を作ることが出来ます。 </p><pre><code>(defparameter *nn* 5)  
 
(defun zero () 0) ; コンストラクタ  
(defun succ (n) (1+ n)) ; コンストラクタ  
(defun succ-inv (n) (1- n)) ; コンストラクタの逆  
 
(defun fold-nn (f g n)  
  "自然数の重畳関数"  
  (if (zerop n)  
      (funcall g)  
      (funcall f (fold-nn f g (succ-inv n)))))  
 
(equal (fold-nn #'succ #'zero *nn*) *nn*)  
 
(fold-nn (lambda (list) (cons 0 list)) (lambda () nil) *nn*)  
 
(fold-nn (lambda (list) (cons (length list) list)) (lambda () nil) *nn*) </code></pre><p>最後の例は、REPLでの評価結果を与えずにおきます。 この重畳関数はループ処理と同じことを行うのですが、ぜひ皆さん自身で確かめてみてください。 </p><p>一見、今までの重畳関数と違って見えますが、この自然数の例も同じ数学的事柄で説明することが出来ます。 </p><h3>まとめと次回</h3><p>今回は、色々な構造に対して重畳関数を書くことで次のことを確かめました。 </p><ol><li>ある構造の重畳関数は、その構造のコンストラクタから定まる。重畳関数は構造をばらして同じ方法ではあるが別の構造に組み立て直す関数であると言える。 </li><li>重畳関数に渡す関数は、そのコンストラクタと同じ様な引数をとる。ここで同じ様なというのは、そのコンストラクタの引数でその構造が期待される箇所については重畳関数の返り値を期待する。 </li><li>2の繰り返しになるが、重畳関数が再帰になる箇所は、与える関数に対応するコンストラクタがその構造自身を引数として期待する箇所と同じ箇所である。 </li></ol><p>どうも舌足らずで、言葉では説明しきれなかった気もしますが、ぜひ他の構造についても重畳関数を書いて見ることで、理解をして頂けたらなと思います。 機会があれば、また何らかの形でお伝えしたいなと思います。 </p><p>次回で、このシリーズは最終回となります。最終回では、圏論の簡単な紹介と、今回書いた様なデータ構造と重畳関数に対応する数学的概念であるF始代数とcatamorphismを紹介したいと思います。 </p></div><footer id="article-footer">UP: <a href=".html"></a> PREV: <a href="fold-with-lisp-2.html">fold-with-lisp-2</a> NEXT: <a href="fold-with-lisp-4.html">fold-with-lisp-4</a></footer></main><footer id="main-footer"><div id="icons"><a href="https://twitter.com/myao_s_moking"><img src="img/twit.png" class="icon-img" /></a><a href="https://github.com/myaosato"><img src="img/github.png" class="icon-img" /></a></div><div id="copyright">&copy;2010 Satoaki Miyao</div></footer></body></html>