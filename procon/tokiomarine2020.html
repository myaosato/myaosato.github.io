<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>訥弁日記</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+JP:300,400,500,700&display=swap" rel="stylesheet"> 
    <link href="/css/themes/sample/base.css" rel="stylesheet">
    <link href="/css/themes/sample/layout.css" rel="stylesheet">
    <link href="/css/themes/sample/module.css" rel="stylesheet">
    <link href="/css/themes/sample/sample.css" rel="stylesheet">
    <link rel="stylesheet"
      href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.0/build/styles/default.min.css">
    <script src="/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <header class="header">
      <div class="header_inner">
        <div class="header_content">
          <div class="header_content_title">
            <a href="/">訥弁日記 <span class="header_content_title_sub">- LISPing Diary -</span></a>
          </div>
        </div>
      </div>
    </header>
    <main class="main-section th-sample">
<h1>東京海上日動 プログラミングコンテスト 2020</h1>
<p>2020-06-13</p>
<p>コンテスト中に挑戦した問題についての感想とか.</p>
<p><a href="https://atcoder.jp/contests/tokiomarine2020/submissions?f.Task=&f.Language=&f.Status=&f.User=myaosato">私の解答</a></p>
<h2>A - Nickname</h2>
<p><a href="https://atcoder.jp/contests/tokiomarine2020/tasks/tokiomarine2020_a">問題</a></p>
<p>与えられた文字列Sから3文字の(連続する)部分文字列をどれでも良いので取り出す問題.</p>
<p>sは3文字以上なのでこの操作はいつでも可能な設定.
先頭から3文字取れば良いだけ.</p>
<h2>B - Tag</h2>
<p><a href="https://atcoder.jp/contests/tokiomarine2020/tasks/tokiomarine2020_b">問題</a></p>
<p>中学受験で出てきそうなタイプの問題で,
初期状態は離れている数直線上の2点が等速直線運動して,
与えられた時間内に2点が重なるかどうかを判定する.</p>
<p>問題を読み間違えてしまったのが痛かった.
与えられた初期位置の制限を数直線が閉区間であると読み間違えたので不要な条件を入れてしまった.</p>
<p>途中精度の問題と勘違いしたのもアレ.</p>
<p>問題分をよく読もう.</p>
<h2>C - Lamps</h2>
<p><a href="https://atcoder.jp/contests/tokiomarine2020/tasks/tokiomarine2020_c">問題</a></p>
<p>与えられた回数ある操作を行った結果を出力する問題.</p>
<p>まず, 速さ間に合わないと分かりつつ愚直に書いたところは良かった.</p>
<p>競技プログラミングでも今の私のレート帯だと, 簡単に作ってボトルネックを解除するというやり方は有効だと思う.
(前回のARC級NOMURA2020はそれでうまく行った.)</p>
<p>その後時間短縮のために, 結果が収束する場合の判定を入れたのも良かった.</p>
<p>ここからが良くなかった.
これで間に合わないことが提出してみて分かったので, さてどうするかとなった時に,
1回の操作の計算量が大きいことは分かっていたがこれをどうにかする方法をすぐに思いつかず敢え無くという結果.</p>
<p>どちらかと言うと思考が全体として計算量を減らすことを考えてしまったのが良くなかった.</p>
<p>ということで時間内に解けずだった.</p>
<p>なお解法としては, 累積和の考え方を用いる.</p>
<p>ネットの情報からは累積和という言葉が何を指しているかどうにもハッキリと分からなかったので,
以下で定義も与えておく.</p>
<p>ここでは, O(1)アクセス可能なシーケンシャルな構造aに対して, 累積和を録るという操作を</p>
<pre><code class="language-Lisp">(loop :for i :from (1+ start) :to end
    (setf (aref a i) (+ (aref a i) (aref a (1- i))))
</code></pre>
<p>とする. (ここでは破壊的に書いた)</p>
<p>この操作後のaを累積和と呼ぶことにする.</p>
<p>i番目の要素は元のシーケンスのi番目以下の要素の和となるような操作である.</p>
<p>累積和を作っておくと, 元のシーケンスのi番目の要素からj番目の要素の和を求めたいなら
累積和のj番目の要素から累積和のi - 1番目の要素を引くことでO(1)で求められる.</p>
<p>N個閉区間(重複可)に均等に値v_iを足す操作を長さM配列に行う場合は,</p>
<ul>
<li>長さMの配列Sの初期化: O(M)</li>
<li>用意した配列に対して, 区間の始点にv_iを足して, 区間の終点からv_i引くという前処理を行う: O(N)</li>
<li>前処理した配列の累積和をとる: O(M)</li>
</ul>
<p>の様に処理することでO(M+N)で処理が出来る.
もし愚直にやったら閉伊区間の長さの平均をLとしてO(LM)かかる.</p>
<p>解けなかったが, 解説を見て勉強になった問題であった.</p>
<p>当面はARC級はCまで解くことを目標にしたい.</p>

    </main>
    <footer class="footer">
      <div class="footer_inner">
        <div class="footer_content">
          <div class="footer_content_copyright">&copy;2010 Satoaki Miyao</div>
        </div>
      </div>
    </footer>
  </body>
</html>