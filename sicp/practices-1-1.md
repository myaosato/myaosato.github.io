# SICP 練習問題 解答(1)

## 練習問題 1.1

```racket
> 10
10
> (+ 5 3 4)
12
> (- 9 1)
8
> (/ 6 2)
3
> (+ (* 2 4) (- 4 6))
6
> (define a 3)
> (define b (+ a 1))
> (+ a b (* a b))
19
> (= a b)
#f
> (if (and (> b a) (< b (* a b)))
      b
      a)
4
> (cond ((= a 4) 6)
         (= b 4) (+ 6 7 a))
4
> (cond ((= a 4) 6)
        ((= b 4) (+ 6 7 a))
        (else 25))
16
> (+ 2 (if (> b a) b a))
6
> (* (cond ((> a b) a)
           ((< a b) b)
           (else -1))
     (+ a 1))
16
> 
```

## 練習問題 1.2

```racket
(/ (+ 5 4 (- 2 (- 3 (+ 6 4/5))))
   (* 3 (- 6 2) (- 2 7)))
```

## 練習問題 1.3

```racket
(define (f x y z)
  (cond ((and (> y z) (> x z)) (+ (* x x) (* y y)))
        ((and (> y x) (> z x)) (+ (* y y) (* z z)))
        (else (+ (* z z) (* x x)))))
```

## 練習問題 1.4

`b`が正かどうかによって`+`あるいは`-`が適用される.

## 練習問題 1.5

`p`を評価すると無限ループに落ちる.

そのため適用順序評価では引数評価時点で落ちるが, 正規順序評価では第2引数は評価されないので0が返される.

## 練習問題 1.6

`new-if`は第2引数も第3引数も必ず評価される. 結果, `sqrt-iter`の呼び出しが毎回評価されるので, 無限ループに落ちる.

## 練習問題 1.7

### 小さい数の時.
真の答えと推定値の差が小さくなるため, あまりに小さい数であれば, 収束しきる前に計算が停止する.

この場合, どう近づくかということを正確に判断できない領域が存在する.

それはそうと, 邦訳で, `effective`が効率的とされているが, 実効的とか効果的の方が良い気がする. 

### 大きい数の時.

2つの大きな数の差を表現することを考えた時に, 絶対的な0.001のような値より必ず大きくなるということがあり得る.

この時, 無限の精度では答えに近づくはずの更新した値が, 変化しないということがある. よって無限ループに落ちる場合がある.

こちらの場合は, どれだけ近づくかということを正確に判断できない領域が存在する.

### 改良案

改良案では, どれだけ近付くかということを相対的な値を用いることで解決し,
どう近付くかということを推定値の変化で解決するため, 改良される.


## 練習問題 1.8

improveを書き換える.

